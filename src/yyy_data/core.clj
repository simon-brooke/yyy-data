(ns yyy-data.core
  (:require [adl-support.utils :refer :all]
            [fastmath.complex :refer [pow]]
            [fastmath.core :refer [radians degrees sin cos tan sqrt atan2]]
            [clojure.core.matrix :as mx]
            [clojure.data.json :as json]
            [clojure.math.numeric-tower :refer [expt]]
            [clojure.string :as s]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; yyy-data.core
;;;;
;;;; This program is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU General Public License
;;;; as published by the Free Software Foundation; either version 2
;;;; of the License, or (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
;;;; USA.
;;;;
;;;; Copyright (C) 2018 Simon Brooke
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Coordinate system conversion cribbed from https://www.movable-type.co.uk/scripts/latlong-os-gridref.html

;;; There are a number of bad design decisions in my re-implementation of this.
;;; Using protocols and records was probably a mistake.
;;;
;;; The decision not only to adopt but to extend the untypable variable names
;;; of the original was DEFINITELY a mistake.
;;;
;;; Pragmatically, trying to translate the Javascript file was a mistake. I should
;;; just wrap it in a webservice and call it. Less elegant but I don't have time
;;; to mess around.



(declare geopoint->osgrid vector3d->geopoint geopoint->vector3d osgrid->geopoint)


(def ellipsoids
  "Ellipsoid parameters; major axis (a), minor axis (b), and flattening (f) for each ellipsoid."
  {
    :WGS84         { :a 6378137     :b 6356752.314245 :f (/ 1 298.257223563) }
    :Airy1830      { :a 6377563.396 :b 6356256.909    :f (/ 1 299.3249646)   }
    :AiryModified  { :a 6377340.189 :b 6356034.448    :f (/ 1 299.3249646)   }
    :Bessel1841    { :a 6377397.155 :b 6356078.962818 :f (/ 1 299.1528128)   }
    :Clarke1866    { :a 6378206.4   :b 6356583.8      :f (/ 1 294.978698214) }
    :Clarke1880IGN { :a 6378249.2   :b 6356515.0      :f (/ 1 293.466021294) }
    :GRS80         { :a 6378137     :b 6356752.314140 :f (/ 1 298.257222101) }
    :Intl1924      { :a 6378388     :b 6356911.946    :f (/ 1 297)           } ;; aka Hayford
    :WGS72         { :a 6378135     :b 6356750.5      :f (/ 1 298.26)        }
    })


(def datums
  "Datums; with associated ellipsoid, and Helmert transform parameters to convert from WGS 84 into
  given datum.

  Note that precision of various datums will vary, and WGS-84 (original) is not defined to be
  accurate to better than Â±1 metre. No transformation should be assumed to be accurate to better
  than a meter; for many datums somewhat less.

  Yes, I know that the plural of datum is data..."
  {
    ;; transforms: t in metres, s in ppm, r in arcseconds                               tx            ty           tz           s          rx          ry           rz
    :ED50        { :key :ED50       :ellipsoid (ellipsoids :Intl1924)      :transform { :tx   89.5,   :ty   93.8   :tz  123.1   :s -1.2    :rx  0.0    :ry  0.0     :rz  0.156  }}
    :Irl1975     { :key :Irl1975    :ellipsoid (ellipsoids :AiryModified)  :transform { :tx -482.530  :ty  130.596 :tz -564.557 :s -8.150  :rx -1.042  :ry -0.214   :rz -0.631  }}
    :NAD27       { :key :NAD27      :ellipsoid (ellipsoids :Clarke1866)    :transform { :tx    8      :ty -160     :tz -176     :s  0      :rx  0      :ry  0       :rz  0      }}
    :NAD83       { :key :NAD83      :ellipsoid (ellipsoids :GRS80)         :transform { :tx    1.004  :ty   -1.910 :tz   -0.515 :s -0.0015 :rx  0.0267 :ry  0.00034 :rz  0.011  }}
    :NTF         { :key :NTF        :ellipsoid (ellipsoids :Clarke1880IGN) :transform { :tx  168      :ty   60     :tz -320     :s  0      :rx  0      :ry  0       :rz  0      }}
    :OSGB36      { :key :OSGB36     :ellipsoid (ellipsoids :Airy1830)      :transform { :tx -446.448  :ty  125.157 :tz -542.060 :s 20.4894 :rx -0.1502 :ry -0.2470  :rz -0.8421 }}
    :Potsdam     { :key :Potsdam    :ellipsoid (ellipsoids :Bessel1841)    :transform { :tx -582      :ty -105     :tz -414     :s -8.3    :rx  1.04   :ry  0.35    :rz -3.08   }}
    :TokyoJapan  { :key :TokyoJapan :ellipsoid (ellipsoids :Bessel1841)    :transform { :tx  148      :ty -507     :tz -685     :s  0      :rx  0      :ry  0       :rz  0      }}
    :WGS72       { :key :WGS72      :ellipsoid (ellipsoids :WGS72)         :transform { :tx    0      :ty    0     :tz   -4.5   :s -0.22   :rx  0      :ry  0       :rz  0.554  }}
    :WGS84       { :key :WGS84      :ellipsoid (ellipsoids :WGS84)         :transform { :tx    0.0    :ty    0.0   :tz    0.0   :s  0.0    :rx  0.0    :ry  0.0     :rz  0.0    }}
    })


(defprotocol Location
  "A location on the surface of the earth"
  (datum [location])
  (datum-key [location])
  (ellipsoid [location])
  (geopoint [location datum])
  (grid-x [location])
  (grid-y [location])
  (latitude [location])
  (longitude [location])
  (osgrid [location datum])
  (vector3d [location]))


(defprotocol Transformable
  "Something which can be transformed with a matrix transform."
  (apply-transform [this transform]))


(defrecord Vector3d
  ;; "A vector from the centre of the earth, which intercepts the surface at a point."
  [x y z]
  Location
  ;; datum is a bit meaningless for a Vector3d; get the default.
  (datum [x] (datums :WGS84))
  (datum-key [x] :WGS84)
  (ellipsoid [x] (:ellipsoid (datum x)))
  ;; I already am vector3d; return myself
  (vector3d [x] x)
  (geopoint [this datum] (vector3d->geopoint this datum))
  (osgrid [this datum] (geopoint->osgrid (vector3d->geopoint this datum) datum))
  Transformable
  (apply-transform [this transform]
                   ;; tests say this works
    (println (str "(apply-transform " this " " transform ")"))
                   (let
                     [s1 (+' (/ (:s transform) 1e6) 1)          ;; scale
                      rx (radians (/ (:rx transform) 3600))     ;; x-rotation: normalise arcseconds to radians
                      ry (radians (/ (:ry transform) 3600))     ;; y-rotation: normalise arcseconds to radians
                      rz (radians (/ (:rz transform) 3600))     ;; z-rotation: normalise arcseconds to radians
                      x2 (-'
                           (+' (:tx transform)
                              (*' (:x this) s1))
                           (+'
                             (*' (:y this) rz)
                             (*' (:z this) ry)))
                      y2 (+'
                           (:ty transform)
                           (*' (:x this) rz)
                           (*' (:y this) s1)
                           (-' 0 (*' (:z this) rx)))
                      z2 (+'
                           (:tz transform)
                           (-' 0 (*' (:x this) ry))
                           (*' (:y this) rx)
                           (*' (:z this) s1))]
                     (Vector3d. x2 y2 z2))))


(defn inverse-transform
  "Return a transform which is the inverse of `t`. More generally,
  expects a map `t` whose values are numbers, and returns a map which has
  for each key in `t` a number which is the inverse of the value of the
  same key in `t`."
  ;; tests say this works
  [t]
  (reduce
    merge
    {}
    (map
      #(if (number? (t %)) (hash-map % (-' 0 (t %)))) ;; (hash-map % (t %)))
      (keys t))))


;; (inverse-transform { :tx   89.5,   :ty   93.8   :tz  123.1   :s -1.2    :rx  0.0    :ry  0.0    :rz  0.156  })


(defn to-fixed
  "Round the number `n` to `p` places after the decimal point."
  [n p]
  (let [m (reduce *' 1 (repeat p 10))]
    (double (/ (bigint (*' n m)) m))))


;; (to-fixed 1234.56789 4)


(defrecord GeoPoint
  [latitude longitude datum]
  ;;   "A point with an `x` co-ordinate, a `y` co-ordinate, and a datum `d`. `d`
  ;;    must be a key taken from `datums`, q.v."
  Location
  (datum [location]
         (cond
           (keyword? (:datum location))
           (datums (:datum location))
           (map? (:datum location))
           (:datum location)))
  (datum-key [location]
             (cond
               (keyword? (:datum location))
               (:datum location)
               (map? (:datum location))
               (:key (:datum location))))
  (ellipsoid [location]
             (:ellipsoid (datum [location])))
  (vector3d [this] (geopoint->vector3d this))
  (geopoint [location new-datum]
    (println (str "(geopoint " location " " new-datum ")"))
    (if
      (= (:datum location) new-datum)
      location
      (let [od (datum location)
            nd (datums new-datum)
            c (geopoint->vector3d location)]
        (cond
          (= od nd) location
          (= (:key od) :WGS84) (vector3d->geopoint
                                 (apply-transform c (:transform nd))
                                 (:datum location))
          (= (:key nd) :WGS84) (geopoint
                                 (apply-transform
                                   c
                                   (inverse-transform
                                     (:transform od)))
                                 (:datum location))
          true
          (geopoint (geopoint location :WGS84) new-datum)))))
  (latitude [location]
            (:latitude (geopoint location :WGS84)))
  (longitude [location]
             (:longitude (geopoint location :WGS84)))
  (grid-x [location]
          (:e (osgrid location (:datum location))))
  (grid-y [location]
          (:n (osgrid location (:datum location))))
  (osgrid [location datum]
          (geopoint->osgrid location datum)))


(defrecord OsGrid
  [e n]
  Location
  ;;  "A location on the surface of the earth"
  (datum [location] (:WGS84 datums))
  (datum-key [location] :WGS84)
  (ellipsoid [location] (:ellipsoid :WGS84))
  (grid-x [location] e)
  (grid-y [location] n)
  (latitude [location] (latitude (geopoint location :WGS84)))
  (longitude [location] (longitude (geopoint location :WGS84)))
  (vector3d [location] (geopoint->vector3d (osgrid->geopoint location :WGS84)))
  (geopoint [location datum]
            (osgrid->geopoint location datum))
  (osgrid [location datum] location))


(defn raw-vector3d->geopoint
  ([v datum]
   (vector3d->geopoint (:x v) (:y v) (:z v) datum))
  ([x y z d]
   (let
     [a (:a (:ellipsoid (datums d)))
      b (:b (:ellipsoid (datums d)))
      f (:f (:ellipsoid (datums d)))
      eÂ² (-' (*' 2 f) (*' f f)) ;; first eccentricity squared
      ÎµÂ² (/ eÂ² (-' 1 eÂ²)) ;; second eccentricity squared
      p (sqrt (+' (*' x x) (*' y y)))
      ;; distance from minor radius
      R (sqrt (+' (*' p p) (*' z z)))
      ;; polar radius
      tanÎ² (*' (/ (*' b z)(*' a p)) (/ (*' b (+' 1 ÎµÂ²)) R))
      sinÎ² (/ tanÎ² (sqrt (+' 1 (*' tanÎ² tanÎ²))))
      cosÎ² (/ sinÎ² tanÎ²)
      Ï (if
          (Double/isNaN cosÎ²) 0
          (atan2 (+' z (*' ÎµÂ² b sinÎ² sinÎ² sinÎ²))
                 (-' p (*' eÂ² a cosÎ² cosÎ² cosÎ²))))
      Î» (atan2 y x)
      v (/ a (sqrt (-' 1 (*' eÂ² (sin Ï) (sin Ï)))))]
     (GeoPoint. (degrees Ï) (degrees Î») d))))


;; memoisation here is used more to break mutual recursion than to speed things
;; up, although of course it will also speed things up a bit.
(def vector3d->geopoint (memoize raw-vector3d->geopoint))


(defn raw-geopoint->osgrid
  ([gp datum]
   (geopoint->osgrid (:latitude gp) (:longitude gp) (:datum gp) datum))
  ([latitude longitude from-datum to-datum]
   ;; for bizarrely over-complicated trigonometry, look no further.
   ;; This doesn't work. But, to be brutally honest, I don't need it to.
   (let [point (GeoPoint. latitude longitude to-datum)
         Ï     (radians latitude)
         Î»     (radians longitude)
         a     6377563.396       ;; Airy 1830 major semi-axis
         b     6356256.909       ;; Airy 1830 minor semi-axis
         F0    0.9996012717      ;; OS Grid scale factor on central meridian
         Ï0    (radians 49)      ;; OS Grid true origin latitude
         Î»0    (radians -2)      ;; OS Grid true origin longitude
         ÎÏ    (-' Ï Ï0)         ;; latitude offset from origin
         ÎÎ»    (-' Î» Î»0)         ;; longitude offset from origin
         ÎÎ»Â²   (expt ÎÎ» 2)
         ÎÎ»Â³   (expt ÎÎ» 3)
         ÎÎ»â´   (expt ÎÎ» 4)
         ÎÎ»âµ   (expt ÎÎ» 5)
         ÎÎ»â¶   (expt ÎÎ» 6)
         N0    -100000           ;; northing of true origin, metres
         E0    400000            ;; easting of true origin, metres
         eÂ²    (-' 1 (/ (*' b b) (*' a a)))  ;; eccentricity squared
         n     (/ (-' a b) (+' a b))
         nÂ²    (*' n n)
         nÂ³    (*' n n n)
         sinÏ  (sin Ï)
         sinÂ²Ï (*' (sin Ï) (sin Ï))
         cosÏ  (cos Ï)
         v     (*' a (/ F0 (sqrt (-' 1 (*' eÂ² sinÂ²Ï)))))
         ;; nu = transverse radius of curvature
         Ï     (/ (*' a F0 (-' 1 eÂ²)) (expt (-' 1 (*' eÂ² sinÂ²Ï)) 1.5))
         ;; rho = meridional radius of curvature
         Î·2    (/ v (-' Ï 1))     ;; beware confusing Î·2 with nÂ²
         Ma    (*' (+' 1 n (*' (/ 5 4) nÂ²) (*' (/ 5 4) nÂ³)) ÎÏ)
         Mb    (*
                 (+' (*' 3 n) (*' 3 nÂ²) (*' (/ 21 8) nÂ³))
                 (sin ÎÏ) (cos (+' Ï Ï0)))
         Mc    (*
                 (+' (*' (/ 15 8) nÂ²) (*' (/ 15 8) nÂ³))
                 (sin (*' 2 ÎÏ)) (cos (*' 2 (+' Ï Ï0))))
         Md    (*' (/ 35 24) nÂ³ (sin (*' 3 ÎÏ)) (cos (*' 3 (+' Ï Ï0))))
         M     (*' b F0 (+' (-' Ma Mb) (-' Mc Md)))
         ;; meridional arc
         cosÂ³Ï (reduce * 1 (repeat 3 cosÏ))
         cosâµÏ (reduce * 1 (repeat 5 cosÏ))
         tanÂ²Ï (reduce * 1 (repeat 2 (tan Ï)))
         tanâ´Ï (reduce * 1 (repeat 4 (tan Ï)))
         I     (+' M N0)
         II    (*' (/ v 2) sinÏ cosÏ)
         III   (*' (/ v 24) sinÏ cosÂ³Ï (-' 5 (+' tanÂ²Ï (*' 9 Î·2))))
         ;; var IIIA = (Î½/720)*sinÏ*cos5Ï*(61-58*tan2Ï+tan4Ï);
         ;; TODO: CHECK JAVASCRIPT OPERATOR PRECEDENCE!
         IIIA  (*' (/ v 720) sinÏ cosâµÏ (-' 61 (+' (*' 58 tanÂ²Ï) tanâ´Ï)))
         IV    (*' v cosÏ)
         V     (*' (/ v 6) cosÂ³Ï (-' (/ v Ï) tanÂ²Ï))
         ;; var VI = (Î½/120) * cos5Ï * (5 - 18*tan2Ï + tan4Ï + 14*Î·2 - 58*tan2Ï*Î·2);
         VI    (*
                 (/ v 120)
                 cosâµÏ
                 (-' 5
                    (+' (*' 18 tanÂ²Ï)
                       tanâ´Ï
                       (*' 14 Î·2) (-' 0 (*' 58 tanÂ²Ï Î·2)))))
         N     (to-fixed (+' I (*' II ÎÎ»Â²) (+' III ÎÎ»â´) (*' IIIA ÎÎ»â¶)) 3)
         E     (to-fixed (+' E0 (*' IV ÎÎ») (*' V ÎÎ»Â³) (*' VI ÎÎ»âµ)) 3)]
     (OsGrid. E N))))


(def geopoint->osgrid (memoize raw-geopoint->osgrid))


(defn raw-geopoint->vector3d
  ([gp]
   (println (str "(geopoint->vector3d " geopoint ")"))
   (geopoint->vector3d (:latitude gp) (:longitude gp) (datum gp)))
  ([latitude longitude datum]
   (let [Ï (radians latitude)
         Î» (radians longitude)
         h 0
         a (:a (:ellipsoid datum))
         f (:f (:ellipsoid datum))
         sinÏ (sin Ï)
         cosÏ (cos Ï)
         sinÎ» (sin Î»)
         cosÎ» (cos Î»)
         eÂ² (-' (*' 2 f) (*' f f))
         v (/ a (sqrt (-' 1 (*' eÂ² sinÏ sinÏ))))]
     (Vector3d.
       (*' (+' v h) cosÏ cosÎ»)
       (*' (+' v h) cosÏ sinÎ»)
       (*' v (+' h (-' 1 eÂ²)) sinÏ)))))


(def geopoint->vector3d (memoize raw-geopoint->vector3d))


(defn raw-osgrid->geopoint
  ([osgrid]
   (osgrid->geopoint osgrid :WGS84))
  ([osgrid datum]
   (osgrid->geopoint (:e osgrid) (:n osgrid) datum))
  ([E N datum]
   (let
     [a     6377563.396         ;; Airy 1830 major semi-axis
      b     6356256.909         ;; Airy 1830 minor semi-axis
      F0    0.9996012717        ;; national grid scale factor on central meridian
      Ï0    (radians 49)        ;; national grid true origin latitude
      Î»0    (radians -2)        ;; national grid true origin longitude
      N0    -100000             ;; northing of true origin, metres
      E0    400000              ;; easting of true origin, metres
      eÂ²    (-' 1
               (/
                 (*' b b)
                 (*' a a)))      ;; eccentricity squared
      n     (/ (-' a b) (+' a b))
      nÂ²    (expt n 2)
      nÂ³    (expt n 3)
      [M Ï] (loop  [Ï Ï0 M 0]
              (let
                [Ïâ (+' Ï (/ (-' N N0 M) (*' a F0)))
                 ÎÏ (-' Ïâ Ï0)
                 Ma (*' (+' 1 n (*' 5/4 nÂ²) (*' 5/4 nÂ³)) ÎÏ)
                 Mb (*' (+' (*' n 3) (*' nÂ² 3) (*' 21/8 nÂ³)) (sin ÎÏ) (cos (+' Ïâ Ï0)))
                 Mc (*' (+' (*' nÂ² 15/8) (*' nÂ³ 15/8)) (sin (*' 2 ÎÏ)) (cos (*' 2 (+' Ïâ Ï0))))
                 Md (*' 35/24 nÂ³ (sin (*' 3 ÎÏ)) (cos (*' 3 (+' Ïâ Ï0))))
                 Mâ (*' b F0 (+' (-' Ma Mb) (-' Mc Md)))]
                (if
                  (>= (-' N N0 Mâ) 0.00001)
                  (recur Ïâ Mâ)
                  [Mâ Ïâ])))
      sinÏ  (sin Ï)
      sinÂ²Ï (*' (sin Ï) (sin Ï))
      cosÏ  (cos Ï)
      ;; nu = transverse radius of curvature
      v     (*' a (/ F0 (sqrt (-' 1 (*' eÂ² sinÂ²Ï)))))
      vÂ³    (expt 3 v)
      vâµ    (expt 5 v)
      vâ·    (expt 7 v)
      ;; rho = meridional radius of curvature
      Ï     (/ (*' a F0 (-' 1 eÂ²)) (expt (-' 1 (*' eÂ² sinÂ²Ï)) 1.5))
      Î·2    (/ v (-' Ï 1))     ;; beware confusing Î·2 with nÂ²
      tanÏ  (tan Ï)
      tanÂ²Ï (expt tanÏ 2)
      tanâ´Ï (expt tanÏ 4)
      tanâ¶Ï (expt tanÏ 6)
      secÏ  (/ 1 cosÏ)
      VII   (/ tanÏ (*' 2 Ï v))
      VIII  (*' (/ tanÏ (*' 24 Ï vÂ³)) (+' 5 (*' 3 tanÂ²Ï) Î·2 (-' 0 (*' 9 tanÂ²Ï Î·2))))
      IX    (*' (/ tanÏ (*' 720 Ï vâµ)) (+' 61 (*' 90 tanÂ²Ï) (*' 45 tanâ´Ï)))
      X     (/ secÏ v)
      XI    (*' (/ secÏ (*' 6 vÂ³)) (+' (/ v Ï) (*' 2 tanÂ²Ï)))
      XII   (*' (/ secÏ (*' 120 vâµ)) (+' 5 (*' 28 tanÂ²Ï) (*' 24 tanâ´Ï)))
      XIIA  (*' (/ secÏ (*' 5040 vâ·)) (+' 61 (*' 622 tanÂ²Ï) (*' 1322 tanâ´Ï) (*' 720 tanâ¶Ï)))
      Îe    (-' E E0)
      ÎeÂ²   (expt Îe 2)
      ÎeÂ³   (expt Îe 3)
      Îeâ´   (expt Îe 4)
      Îeâµ   (expt Îe 5)
      Îeâ¶   (expt Îe 6)
      Îeâ·   (expt Îe 7)
      Ïâ    (-' (+' (-' Ï (*' VII ÎeÂ²)) (*' VIII Îeâ´)) (*' IX Îeâ¶))
      Î»â    (-' (+' (-' (+' Î»0 (*' X Îe)) (*' XI ÎeÂ³)) (*' IX Îeâµ)) (*' XIIA Îeâ·))]
     (GeoPoint. (degrees Ïâ) (degrees Î»â) :WGS84))))


(def osgrid->geopoint (memoize raw-osgrid->geopoint))


(defn post-code-data->addresses
  "`filename` is expected to be the path name of a JSON file containing records as documented
  [here](https://apidocs.os.uk/docs/os-places-dpa-output)."
  [filename]
  (s/join
    "\n\n"
    (map
      (fn [a]
        (let [location (.geopoint (OsGrid. (:x_coordinate a) (:y_coordinate a)) :WGS84)]
          (s/join
            "\n"
            (list
              (str
                "insert into addresses (address, postcode, latitude, longitude) values ('"
                (:address a) "', '" (:postcode a)
                "', " (.latitude location) "," (.longitude location) ");")
              ;; TODO: doesn't deal intelligently with flats and tenements.
              (str
                "insert into dwellings (address_id, sub_address) "
                "values ((select id from addresses where addresses.address = '"
                (:address a)
                "'), '');")))
          ))
      (filter
        #(= (:classification_code_description %) "Dwelling")
        (map
          :dpa
          (:results
            (json/read-str
              (slurp filename)
              :key-fn #(keyword (.toLowerCase %)))))))))


